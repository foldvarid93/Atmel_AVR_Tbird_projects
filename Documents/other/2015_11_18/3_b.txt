//a kiíratás független a számlálástól!

#include <avr/interrupt.h>
#include <avr/io.h>
#define FIRED 1
#define RESET 0


volatile unsigned int seg7=0;//bármikor átírható!!!!!!!!!4
volatile unsigned int  timer_5ms=RESET;
volatile unsigned int  timer_1s=RESET;

 

void init()
{

	DDRA=0xFF;
	DDRD=0xF0;
	DDRB=0xF0;
	DDRG=0x00;

	TCCR1A=0;
	TCCR1B=((1<<WGM12)	|	(1<<CS10));	//1-et shiftelem wgm12-nyivel,ez egy módszer a bitek SETelelésére
	TCCR1C=0;
	

	//f=(F_cpu/(2*prescaller*(1+OCRnA))
	OCR1A=7999;
	
	TIMSK|=(1<< OCIE1A);
	sei();
	
}


void show7()
{
	static int digit=0;		//ha static akkor a compliner a legelején befordítja,csak a függvéneyem tud belenyúlni

	if(digit==0) PORTA=0b10000000	|	(digit<<4)	|	(seg7%10);
	if(digit==1) PORTA=0b10000000	|	(digit<<4)	|	(seg7%100)/10;
	if(digit==2) PORTA=0b10000000	|	(digit<<4)	|	(seg7%1000)/100;
	if(digit==3) PORTA=0b10000000	|	(digit<<4)	|	 seg7/1000;
	//digit++;
	if(++digit >= 4) digit=0;
	
	
	
	
}

ISR(TIMER1_COMPA_vect)
{

	static unsigned int tick_5ms=0;	
	static unsigned int tick_1s=0;
	static unsigned int tick;

	
		

	tick_5ms++;
	if(tick_5ms >= 5)
	{
		tick_5ms=0;
		timer_5ms=FIRED;		
		
	}

	tick_1s++;
	if(tick_1s >= 1000)
	{
		tick_1s=0;
		timer_1s=FIRED;		
		
	}


	

}



int main()
{
	

	init();

	while(1)
	{
		

		if(timer_1s)
		{
			timer_1s=RESET;
			seg7++;

		}



		if(timer_5ms)
		{
			timer_5ms=RESET;
			show7();

		}

	}
	
	return 0;
}






















































































